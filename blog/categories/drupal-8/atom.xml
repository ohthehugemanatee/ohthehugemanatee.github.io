<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Drupal 8 | Oh The Huge Manatee]]></title>
  <link href="http://ohthehugemanatee.github.io/blog/categories/drupal-8/atom.xml" rel="self"/>
  <link href="http://ohthehugemanatee.github.io/"/>
  <updated>2017-07-21T14:18:18+02:00</updated>
  <id>http://ohthehugemanatee.github.io/</id>
  <author>
    <name><![CDATA[Campbell Vertesi (ohthehugemanatee)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Better PHP === Better Drupalists: The PHP Track at Drupalcon Vienna]]></title>
    <link href="http://ohthehugemanatee.github.io/blog/2017/06/15/better-php-better-drupalists/"/>
    <updated>2017-06-15T17:19:24+02:00</updated>
    <id>http://ohthehugemanatee.github.io/blog/2017/06/15/better-php-better-drupalists</id>
    <content type="html"><![CDATA[<p>One of the best parts of Drupal 8 is our shift to enterprise PHP coding structures. With tools like composer and Symfony&rsquo;s structures like Events and Dependency Injection, Drupalists are learning to be great PHP developers, and vice-versa. Today, the fastest route to becoming a rock star Drupalist is through PHP.</p>

<p>I&rsquo;m one of the PHP track chairs for Drupalcon Vienna, and this year our focus is <em>better PHP === better Drupalists</em>. How can better PHP make your life as a Drupal developer easier?</p>

<!-- more -->


<p></p>

<p><strong>Do you like PHP 7?</strong> We want to hear about the technicalities of types, throwing all the things, and your favorite operators (mine is null coalesce, but full respect for you spaceship operator fans).</p>

<p><strong>Have you seen the light of functional programming?</strong> Tell us why we should love higher orders with lambda functions and closures. Let&rsquo;s hear the finer points of first class functions.</p>

<p><strong>Do your tests bring all the bugs to the yard?</strong> We want to talk about it. Every method is a promise, and your tests make sure you keep your promises. We want sessions about test driven development in a drupal context, choosing the right test framework and scope, and how your real-world tests are saving you real-world time.</p>

<p><strong>Have you written a composer library wrapper module yet?</strong> Submit a session about how composer is saving you lines of code.</p>

<p><strong>Is your development environment fine-tuned for drupal excellence?</strong> Tell us how, and why.</p>

<p>We have only two weeks left until session submissions close! <a href="https://events.drupal.org/node/add/session?og_group_ref=14447">Get your session in now</a> and help us make Drupal code something to be proud of.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stop Waiting for Feeds Module: How to Import RSS in Drupal 8]]></title>
    <link href="http://ohthehugemanatee.github.io/blog/2017/06/07/stop-waiting-for-feeds-module-how-to-import-remote-feeds-in-drupal-8/"/>
    <updated>2017-06-07T06:33:24+02:00</updated>
    <id>http://ohthehugemanatee.github.io/blog/2017/06/07/stop-waiting-for-feeds-module-how-to-import-remote-feeds-in-drupal-8</id>
    <content type="html"><![CDATA[<p>How do you import an RSS feed into entities with Drupal 8? In Drupal 6 and 7, you probably used the <a href="https://drupal.org/project/feeds">Feeds</a> module. Feeds 7 made it easy (-ish) to click together a configuration that matches an RSS (or any XML, or CSV, or OPML, etc) source to a Drupal entity type, maps source data into Drupal fields, and runs an import with the site Cron. Where has that functionality gone in D8? I recently had to build a podcast mirror for a client that needed this functionality, and I was surprised at what I found.</p>

<p><strong>Feeds module</strong> doesn&rsquo;t have a stable release candidate, and it doesn&rsquo;t look like one is coming any time soon. They&rsquo;re still surveying people about what feeds module should even DO in D8. As the module page explains:</p>

<p><blockquote><p>It&rsquo;s not ready yet, but we are brainstorming about what would be the best way forward. Want to help us? Fill in our survey.<br/>If you decide to use it, don&rsquo;t be mad if we break it later.</p></blockquote></p>

<p>This does not inspire confidence.</p>

<p>The next great candidate is <a href="https://www.drupal.org/docs/8/core/modules/aggregator/overview">Aggregator</a> module (in core). Unfortunately, Aggregator gives you no control over the kind of entity to create, let alone any kind of field mapping. It imports content into its own Aggregated Content entity, with everything in one field, and linking offsite. I suppose you could extend it to choose you own entity type, map fields etc, but that seems like a lot of work for such a simple feature.</p>

<p>Frustrating, right?</p>

<p><strong>What if I told you that Drupal 8 can do everything Feeds 7 can?</strong></p>

<p>What if I told you that it&rsquo;s even better: instead of clicking through endless menus and configuration links, waiting for things to load, missing problems, and banging your head against the mouse, you can set this up with one simple piece of text. You can copy and paste it directly from this blog post into Drupal&rsquo;s admin interface.</p>

<h2>What? How?</h2>

<p>Drupal 8 can do all the Feedsy stuff you like with <a href="https://www.drupal.org/docs/8/api/migrate-api/migrate-api-overview">Migrate</a> module. Migrate in D8 core already contains all the elements you need to build a regular importer of ANYTHING into D8. Add a couple of contrib modules to provide specific plugins for XML sources and convenience drush functions, and <em>baby you&rsquo;ve got a stew goin'!</em></p>

<p>Here&rsquo;s the short version Howto:</p>

<p><strong>1) Download and enable <a href="https://drupal.org/project/migrate_plus">migrate_plus</a> and <a href="https://drupal.org/project/migrate_tools">migrate_tools</a> modules.</strong> You should be doing this with composer, but I won&rsquo;t judge. Just get them into your codebase and enable them. Migrate Plus provides plugins for core Migrate, so you can parse remote XML, JSON, CSV, or even arbitrary spreadsheet data. Migrate Tools gives us drush commands for running migrations.</p>

<p><strong>2) Write your Migration configuration in text</strong>, and paste it into the configuration import admin page (<code>admin/config/development/configuration/single/import</code>), or import it another way. I&rsquo;ve included a starter YAML just below, you should be able to copypasta, change a few values, and be done in time for tea.</p>

<p><strong>3) Add a line to your system cron</strong> to run <code>drush migrate -y my_rss_importer</code> at whatever interval you like.</p>

<p>That&rsquo;s it. One YAML file, most of which is copypasta. One cronjob. All done!</p>

<p>Here&rsquo;s my RSS importer config for your copy and pasting pleasure. If you&rsquo;re already comfortable with migration YAMLs and XPaths, just add the names of your RSS fields as selectors in the source section, map them to drupal fields in the process section, and you&rsquo;re all done!</p>

<p>If you aren&rsquo;t familiar with this stuff yet, don&rsquo;t worry! We&rsquo;ll dissect this together, below.</p>

<p>``` yaml
id: my_rss_importer
label: &lsquo;Import my RSS feed&rsquo;
status: true</p>

<p>source:
  plugin: url
  data_fetcher_plugin: http
  urls: &lsquo;<a href="https://example.com/feed.rss">https://example.com/feed.rss</a>&rsquo;
  data_parser_plugin: simple_xml</p>

<p>  item_selector: /rss/channel/item
  fields:</p>

<pre><code>-
  name: guid
  label: GUID
  selector: guid
-
  name: title
  label: Title
  selector: title
-
  name: pub_date
  label: 'Publication date'
  selector: pubDate
-
  name: link
  label: 'Origin link'
  selector: link
-
  name: summary
  label: Summary
  selector: 'itunes:summary'
-
  name: image
  label: Image
  selector: 'itunes:image[''href'']'
</code></pre>

<p>  ids:</p>

<pre><code>guid:
  type: string
</code></pre>

<p>destination:
  plugin: &lsquo;entity:node&rsquo;</p>

<p>process:
  title: title
  field_remote_url: link
  body: summary
  created:</p>

<pre><code>plugin: format_date
from_format: 'D, d M Y H:i:s O'
to_format: 'U'
source: pub_date
</code></pre>

<p>  status:</p>

<pre><code>plugin: default_value
default_value: 1
</code></pre>

<p>  type:</p>

<pre><code>plugin: default_value
default_value: podcast_episode
</code></pre>

<p>```</p>

<p>Some of you can just stop here. If you&rsquo;re familiar with the format and the structures involved, this example is probably all you need to set up your easy RSS importer.</p>

<p>In the interest of good examples for Migrate module though, I&rsquo;m going to continue. Read on if you want to learn more about how this config works, and how you can use Migrate to do even more amazing things&hellip;</p>

<h2>Anatomy of a migration YAML</h2>

<p>Let&rsquo;s dive into that YAML a bit. Migrate is one of the most powerful components of Drupal 8 core, and this configuration is your gateway to it.</p>

<p>That YAML looks like a lot, but it&rsquo;s really just 4 sections. They can appear in any order, but we need all 4: General information, source, destination, and data processing. This isn&rsquo;t rocket science after all! Let&rsquo;s look at these sections one at a time.</p>

<p><strong>General information</strong></p>

<p><code>yaml
id: my_rss_importer
label: 'My RSS feed importer'
status: true
</code>
This is the basic stuff about the migration configuration. At a minimum it needs a unique machine-readable ID, a human-readable label, and <code>status: true</code> so it&rsquo;s enabled. There are other keys you can include here for fun extra features, like module dependencies, groupings (so you can run several imports together!), tags, and language. These are the critical ones, though.</p>

<p><strong>Source</strong></p>

<p>``` yaml
source:
  plugin: url
  data_fetcher_plugin: file
  urls: &lsquo;<a href="https://example.com/feed.rss">https://example.com/feed.rss</a>&rsquo;
  data_parser_plugin: simple_xml</p>

<p>  item_selector: /rss/channel/item
  fields:</p>

<pre><code>-
  name: guid
  label: GUID
  selector: guid
-
  name: title
  label: Item Title
  selector: title
-
  name: pub_date
  label: 'Publication date'
  selector: pubDate
-
  name: link
  label: 'Origin link'
  selector: link
-
  name: summary
  label: Summary
  selector: 'itunes:summary'
</code></pre>

<p>  ids:</p>

<pre><code>guid:
  type: string
</code></pre>

<p>```
This is the one that intimidates most people: it&rsquo;s where you describe the RSS source. Migrate module is even more flexible than Feeds was, so there&rsquo;s a lot to specify here&hellip; but it all makes sense if you take it in small pieces.</p>

<p>First: we want to use a remote file, so we&rsquo;ll use the Url plugin (there are others, but none that we care about right now). All the rest of the settings belong to the Url plugin, even though they aren&rsquo;t indented or anything.</p>

<p>There are two possibilities for Url&rsquo;s data_fetcher setting: file and http. <code>file</code> is for anything you could pass to PHP&rsquo;s <a href="https://secure.php.net/manual/en/function.file-get-contents.php">file_get_contents</a>, including remote URLs. There are some great performance tricks in there, so it&rsquo;s a good option for most use cases. We&rsquo;ll be using <code>file</code> for our example. <code>http</code> is specifically for remote files accessed over HTTP, and lets you use the full power of the HTTP spec to get your file. Think authentication headers, cache rules, etc.</p>

<p>Next we declare which plugin will read (parse) the data from that remote URL. We can read JSON, SOAP, arbitrary XML&hellip; in our use case this is an RSS feed, so we&rsquo;ll use one of the XML plugins. SimpleXML is just what it sounds like: a simple way to get data out of XML. In extreme use cases you might use XML instead, but I haven&rsquo;t encountered that yet (ever, anywhere, in any of my projects). TL;DR: SimpleXML is great. Use it.</p>

<p>Third, we have to tell the source where it can find the actual items to import. XML is freeform, so there&rsquo;s no way for Migrate to know where the future &ldquo;nodes&rdquo; are in the document. So you have to give it the XPath to the items. RSS feeds have a standardized path: <code>/rss/channel/item</code>.</p>

<p>Next we have to identify the &ldquo;fields&rdquo; in the source. You see, migrate module is built around the idea that you&rsquo;ll map source fields to destination fields. That&rsquo;s core to how it thinks about the whole process. Since XML (and by extension RSS) is an unstructured format &ndash; it doesn&rsquo;t think of itself as having &ldquo;fields&rdquo; at all. So we&rsquo;ll have to give our source plugin XPaths for the data we want out of the feed, assigning each path to a virtual &ldquo;field&rdquo;. These &ldquo;fake fields&rdquo; let Migrate treat this source just like any other.</p>

<p>If you haven&rsquo;t worked with XPaths before, the example YAML in this post gives you most of what you need to know. It&rsquo;s just a simple text system for specifying a tag within an unstructured XML document. Not too complicated when you get into it. You may want to <a href="https://duckduckgo.com/?q=xpath+basics">find a good tutorial</a> to learn some of the tricks.</p>

<p>Let&rsquo;s look at one of these &ldquo;fake fields&rdquo;:</p>

<p>``` yaml</p>

<pre><code>  name: summary
  label: Summary
  selector: 'itunes:summary'
</code></pre>

<p>```
<em>name</em> is how we&rsquo;ll address this field in the rest of the migration. It&rsquo;s the source &ldquo;field name&rdquo;. <em>label</em> is the human readable name for the field. <em>selector</em> is the XPath inside the item. Most items are flat &ndash; certainly in RSS &ndash; so it&rsquo;s basically just the tag that surrounds the data you want. There, was that so hard?</p>

<p>As a side note, you can see that my RSS feeds tend to be for iTunes. Sometimes the world eats an apple, sometimes an apple eats the world. Buy me a beer at Drupalcon and we can argue about standards.</p>

<p>Fifth and finally, we identify which &ldquo;field&rdquo; in the source contains a unique identifier. Migrate module keeps track of the association between the source and destination objects, so it can handle updates, rollbacks, and more. The example YAML relies on the very common (but technically optional) <code>&lt;guid&gt;</code> tag as a unique identifier.</p>

<p><strong>Destination</strong></p>

<p><code>yaml
destination:
  plugin: 'entity:node'
</code>
Yep, it&rsquo;s that simple. This is where you declare what Drupal entity type will receive the data. Actually, you could write any sort of destination plugin for this &ndash; if you want Drupal to migrate data into some crazy exotic system, you can do it! But in 99.9% of cases you&rsquo;re migrating into Drupal entities, so you&rsquo;ll want <code>entity:something</code> here. Don&rsquo;t worry about bundles (content types) here; that&rsquo;s something we take care of in field mapping.</p>

<p><strong>Process</strong></p>

<p>``` yaml
process:
  title: title
  field_remote_url: link
  body: summary
  created:</p>

<pre><code>plugin: format_date
from_format: 'D, d M Y H:i:s O'
to_format: 'U'
source: pub_date
</code></pre>

<p>  status:</p>

<pre><code>plugin: default_value
default_value: 1
</code></pre>

<p>  type:</p>

<pre><code>plugin: default_value
default_value: podcast_episode
</code></pre>

<p>```</p>

<p>This is where the action happens: the process section describes how destination fields should get their data from the source. It&rsquo;s the &ldquo;field mapping&rdquo;, and more. Each key is a destination field, each value describes where the data comes from.</p>

<p>If you don&rsquo;t want to migrate the whole field exactly as it&rsquo;s presented in the source, you can put individual fields through <a href="https://www.drupal.org/docs/8/api/migrate-api/migrate-process-plugins">Migrate plugins</a>. These plugins apply all sorts of changes to the source content, to get it into the shape Drupal needs for a field value. If you want to take a substring from the source, explode it into an array, extract one array value and make sure it&rsquo;s a valid Drupal machine name, you can do that here. I won&rsquo;t do it in my example because that sort of thing isn&rsquo;t common for RSS feeds, but it&rsquo;s definitely possible.</p>

<p>The examples of plugins that you see here are simple ones. <code>status</code> and <code>type</code> show you how to set a fixed field value. There are other ways, but the <code>default_value</code> plugin is the best way to keep your sanity.</p>

<p>The <code>created</code> field is a bit more interesting. The Drupal field is a unix timestamp of the time a node was authored. The source RSS uses a string time format, though. We&rsquo;ll use the <code>format_date</code> plugin to convert between the two. Neat, eh?</p>

<p>Don&rsquo;t forget to map values into Drupal&rsquo;s <code>status</code> and <code>type</code> fields! <code>type</code> is especially important: that&rsquo;s what determines the content type, and nodes can&rsquo;t be saved without it!</p>

<h2>That&rsquo;s it?</h2>

<p>Yes, that&rsquo;s it. You now have a migrator that pulls from any kind of remote source, and creates Drupal entities out of the items it finds. Your system cron entry makes sure this runs on a regular schedule, rather than overloading Drupal&rsquo;s cron.</p>

<p>More importantly, if you&rsquo;re this comfortable with Migrate module, you&rsquo;ve just gained a <em>lot</em> of new power. This is a framework for getting data from anywhere, to anywhere, with a lot of convenience functionality in between.</p>

<p>Happy feeding!</p>

<h2>Tips and tricks</h2>

<p>OK I lied, there is way more to say about Migrate. It&rsquo;s a wonderful, extensible framework, and that means there are lots of options for you. Here are some of the obstacles and solutions I&rsquo;ve found helpful.</p>

<p><strong>Importing files</strong></p>

<p>Did you notice that I didn&rsquo;t map the images into Drupal fields in my example? That&rsquo;s because it&rsquo;s a bit confusing. We actually have an image URL that we need to download, then we have to create a file entity based on the downloaded file, and then we add the File ID to the node&rsquo;s field as a value. That&rsquo;s more complicated than I wanted to get into in the general example.</p>

<p>To do this, we have to create a pipeline of plugins that will operate in sequence, to create the value we want to stick in our field_image.  It looks something like this:</p>

<p>``` yaml
  field_image:</p>

<pre><code>-
  plugin: download
  source:
    - image
    - constants/destination_uri
  rename: true
-
  plugin: entity_generate
</code></pre>

<p>```
Looking at that download plugin, <em>image</em> seems clear. That&rsquo;s the source URL we got out of the RSS feed. But what is <em>constants/destination_uri</em>, I hear you cry? I&rsquo;m glad you asked. It&rsquo;s a constant, which I added in the source section and didn&rsquo;t tell you about. You can add any arbitrary keys to the source section, and they&rsquo;ll be available like this in processing. It is good practice to lump all your constants together into one key, to keep the namespace clean. This is what it looks like:</p>

<p>``` yaml
source:
  &hellip; usual source stuff here &hellip;
  constants:</p>

<pre><code>destination_uri: 'public://my_rss_feed/post.jpg'
</code></pre>

<p>```</p>

<p>Before you ask, yes this is exactly the same as using the <code>default_value</code> plugin. Still, <code>default_value</code> is preferred for readability wherever possible. In this case it isn&rsquo;t really possible.</p>

<p>Also, note that the download plugin lets me set <code>rename: true</code>. This means that in case of a name conflict, a <em>0, </em>1, <em>2, </em>3 etc will be added to the end of the filename.</p>

<p>You can see the whole structure here, of one plugin passing its result to the next. You can chain unlimited plugins together this way&hellip;</p>

<p><strong>Multiple interrelated migrations</strong></p>

<p>One of the coolest tricks that Migrate can do is to manage interdependencies between migrations. Maybe you don&rsquo;t want those images just as File entities, you actually want them in Paragraphs, which should appear in the imported node. Easy-peasy.</p>

<p>First, you have to create a second migration for the Paragraph. Technically you should have a separate Migration YAML for each destination entity type. (yes, <code>entity_generate</code> is a dirty way to get around it, use it sparingly). So we create our second migration just for the paragraph, like this:</p>

<p>``` yaml
id: my_rss_images_importer
label: &lsquo;Import the images from my RSS feed&rsquo;
status: true</p>

<p>source:
  plugin: url
  data_fetcher_plugin: http
  urls: &lsquo;<a href="https://example.com/feed.rss">https://example.com/feed.rss</a>&rsquo;
  data_parser_plugin: simple_xml</p>

<p>  item_selector: /rss/channel/item
  fields:</p>

<pre><code>-
  name: guid
  label: GUID
  selector: guid
-
  name: image
  label: Image
  selector: 'itunes:image[''href'']'
</code></pre>

<p>  ids:</p>

<pre><code>guid:
  type: string
</code></pre>

<p>  constants:</p>

<pre><code>destination_uri: 'public://my_rss_feed/post.jpg'
</code></pre>

<p>destination:
  plugin: &lsquo;entity:paragraph&rsquo;</p>

<p>process:
  type:</p>

<pre><code>plugin: default_value
default_value: podcast_image
</code></pre>

<p>  field_image:</p>

<pre><code>-
  plugin: download
  source:
    - image
    - constants/destination_uri
  rename: true
-
  plugin: entity_generate
</code></pre>

<p>```</p>

<p>If you look at that closely, you&rsquo;ll see it&rsquo;s a simpler version of the node migration we did at first. I did the copy pasting myself! Here are the differences:</p>

<ul>
<li>Different ID and label (duh)</li>
<li>We only care about two &ldquo;fields&rdquo; on the source: GUID and the image URL.</li>
<li>The destination is a paragraph instead of a node.</li>
<li>We&rsquo;re doing the image trick I just mentioned.</li>
</ul>


<p>Now, in the node migration, we can add our paragraphs field to the &ldquo;process&rdquo; section like this:</p>

<p>``` yaml
  field_paragraphs:</p>

<pre><code>plugin: migration_lookup
migration: my_rss_images_importer
source: guid
</code></pre>

<p><code>``
We're using the</code>migration_lookup<code>plugin. This plugin takes the value of the field given in</code>source<code>, and looks it up in</code>my_rss_images_importer<code>to see if anything with that source ID was migrated. Remember where we configured the source plugin to know that</code>guid` was the unique identifier for each item in this feed? That comes in handy here.</p>

<p>So we pass the guid to <code>migration_lookup</code>, and it returns the id of the paragraph which was created for that guid. It finds out what Drupal entity ID corresponds to that source ID, and returns the Drupal entity ID to use as a field value. You can use this trick to associate content migrated from separate feeds, totally separate data sources, or whatever.</p>

<p>You should also add a dependency on <code>my_rss_images_importer</code> at the bottom of your YAML file, like this:</p>

<p>``` yaml
migration_dependencies:
  required:</p>

<pre><code>- my_rss_images_importer
</code></pre>

<p>```</p>

<p>This will ensure that <code>my_rss_images_importer</code> will always run before <code>my_rss_importer</code>.</p>

<p>(NB: in Drupal &lt; 8.3, this plugin is called <code>migration</code>)</p>

<p><strong>Formatting dates</strong></p>

<p>Very often you will receive dates in a format other than what Drupal wants to accept as a valid field value. In this case the <code>format_date</code> process plugin comes in very handy, like this:</p>

<p>```
  field_published_date:</p>

<pre><code>plugin: format_date
from_format: 'D, d M Y H:i:s O'
to_format: 'Y-m-d\TH:i:s'
source: pub_date
</code></pre>

<p>```</p>

<p>This one is pretty self-explanatory: from format, to format, and source. This is important when migrating from Drupal 6, whose date fields store dates differently from 8. It&rsquo;s also sometimes handy for RSS feeds. :)</p>

<p><strong>Drush commands</strong></p>

<p>Very important for testing, and the whole reason we have <code>migrate_plus</code> module installed! Here are some handy drush commands for interacting with your migration:</p>

<ul>
<li><code>drush ms</code>: Gives you the status of all known migrations. How many items are there to import? How many have been imported? Is the import running?</li>
<li><code>drush migrate-rollback</code>: Rolls back one or more migrations, deleting all the imported content.</li>
<li><code>drush migrate-messages</code>: Get logged messages for a particular migration.</li>
<li><code>drush mi</code>: Runs a migration. use <code>--all</code> to run them all. Don&rsquo;t worry, Migrate will sort out any dependencies you&rsquo;ve declared and run them in the right order. Also worth noting: <code>--limit=10</code> does a limited run of 10 items, and <code>--feedback=10</code> gives you an in-progress status line every 10 items (otherwise you get nothing until it&rsquo;s finished!).</li>
</ul>


<p>Okay, now that&rsquo;s really it. Happy feeding!</p>

<p><img class="center" src="/images/feed-me-seymour.gif" title="&ldquo;Feed me, Seymour!&rdquo;" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Build a New Source for Drupal Migrate 8]]></title>
    <link href="http://ohthehugemanatee.github.io/blog/2015/05/02/how-to-build-a-new-source-for-drupal-migrate-8/"/>
    <updated>2015-05-02T16:10:36+02:00</updated>
    <id>http://ohthehugemanatee.github.io/blog/2015/05/02/how-to-build-a-new-source-for-drupal-migrate-8</id>
    <content type="html"><![CDATA[<p>This week I wanted to accomplish a task in Drupal 8 that would be simple in Drupal 7: Import several CSV files, each one related to the others by taxonomy terms. Most importantly, I wanted to do it with <a href="https://drupal.org/project/migrate">Migrate module</a>.</p>

<p>Migrate in Drupal 7 is a fantastic piece of code. It is not designed to be used from the GUI, rather, it provides a framework of &ldquo;source&rdquo;, &ldquo;destination&rdquo;, and &ldquo;migration&rdquo; classes so that even the most convoluted migration is 90% written for you. To create a migration in Drupal 7, you create a custom module, declare your migrations in a hook_info, and then extend the built in &ldquo;migration&rdquo; class. You instantiate one of the given classes for the source material (is it a CSV? JSON? Direct connection to a custom DB?), then one of the classes for the destination (is it a content type? Taxonomy term?). Then you add one simple line of code mapping each field from source to destination. If you know what you&rsquo;re doing, the task I had in mind shouldn&rsquo;t take more than 15 minutes per source.</p>

<p>It&rsquo;s not quite so easy in Drupal 8. First of all, with Migrate in core, we had to greatly simplify the goals for the module. The version of Migrate that is really functional and stable is specifically and <em>only</em> the basic framework. There is a separate migrate_drupal module to provide everything you need for migrating from Drupal 6 or 7. This has been a laser-tight focus on just the essentials, which means there&rsquo;s no UI, very little drush support, and definitely no nice extras like the ability to read non-Drupal sources.</p>

<p>My task this week became to write the first CSV source for Drupal 8 Migrate.</p>

<h1>Drupal 8 Migrate Overview</h1>

<p>Drupal 8 Migrations, when you&rsquo;re using classes that already exist, are actually even easier than Migrate 7. All you do is write a single YAML file for each kind of data you&rsquo;re transferring, and put it in a custom module&rsquo;s <em>config/install</em> directory. Your YAML file gives your migration a name and a group, tells us what the source is for data, maps source fields to destination fields, and tells us what the destination objects are. Here&rsquo;s an example Migration definition file from core. See if you can understand what&rsquo;s being migrated here.</p>

<p>``` yaml
id: d6_system_site
label: Drupal 6 site configuration
migration_groups:
  &ndash; Drupal 6
source:
  plugin: variable
  variables:</p>

<pre><code>- site_name
- site_mail
- site_slogan
- site_frontpage
- site_403
- site_404
- drupal_weight_select_max
- admin_compact_mode
</code></pre>

<p>process:
  name: site_name
  mail: site_mail
  slogan: site_slogan
  &lsquo;page/front&rsquo;: site_frontpage
  &lsquo;page/403&rsquo;: site_403
  &lsquo;page/404&rsquo;: site_404
  weight_select_max: drupal_weight_select_max
  admin_compact_mode: admin_compact_mode
destination:
  plugin: config
  config_name: system.site
```</p>

<p>You probably figured it out: this migration takes the system settings (variables) from a Drupal 6 site, and puts them into the Drupal 7 configuration. Not terribly hard, right? You can even do data transformations from the source field value to the destination.</p>

<p>Unfortunately, the only sources we have so far are for Drupal 6 and 7 sites, pulling directly from the database. If you want to use Migrate 8 the way we used Migrate 7, as an easy way to pull in data from arbitrary sources, you&rsquo;ll have to contribute.</p>

<h1>Writing a source plugin in Migrate_plus</h1>

<p>Enter <a href="https://www.drupal.org/sandbox/mikeryan/migrate_plus">Migrate Plus module</a>. This is the place in contrib, where we can fill out all the rest of the behavior we want from Migrate, that&rsquo;s not necessarily a core requirement. This is where we&rsquo;ll be writing our source plugin.</p>

<p>To add a source plugin, just create a .php file in migrate_plus/src/Plugins/migrate/source . Drupal will discover the new plugin automatically the next time you rebuild the cache. The filename has to be the same as the name of the class, so choose carefully! My file is called CSV.php . Here&rsquo;s the top of the file you need for a basic :</p>

<p>```php
&lt;?php
/<em>*
 * @file
 * Contains \Drupal\migrate_plus\Plugin\migrate\source\csv.
 </em>/</p>

<p>namespace Drupal\migrate_plus\Plugin\migrate\source;</p>

<p>use Drupal\migrate\Plugin\migrate\source\SourcePluginBase;</p>

<p>/<em>*
 * Source for CSV files.
 *
 * @MigrateSource(
 *   id = &ldquo;csv&rdquo;
 * )
 </em>/
class CSV extends SourcePluginBase {
```</p>

<p>I&rsquo;m calling this out separately because for newbies to Drupal 8, this is the hard part. This is all the information that Drupal needs to be able to find your class when it needs it. The @file comment is important. That and the namespace below have to match the actual location of the .php file.</p>

<p>Then you declare any other classes that you need, with their full namespace. To start with all you need is SourcePluginBase.</p>

<p>Finally you have to annotate the class with that @MigrateSource(id=&ldquo;csv&rdquo;). This is how Migrate module knows that this is a MigrateSource, and the name of your Plugin. Don&rsquo;t miss it!</p>

<p>Inside the class, you must have the following methods. I&rsquo;ll explain a bit more about each afterwards.</p>

<ul>
<li>initializeIterator() : Should return a valid Iterator object.</li>
<li>getIds() : Should return an array that defines the unique identifiers of your data source.</li>
<li>__toString() : Should return a simple, string representation of the source.</li>
<li>fields() : Should return a definitive list of fields in the source.</li>
<li>__construct() : You don&rsquo;t NEED this method, but you probably will end up using it.</li>
</ul>


<h2>initializeIterator()</h2>

<p>An Iterator is a complicated sounding word for an Object that contains everything you need to read from a data source, and go through it one line at a time. Maybe you&rsquo;re used to fopen(&lsquo;path/to/file&rsquo;, &lsquo;r&rsquo;) to open a file, and then you write code for every possible operation with that file. An iterator takes care of all that for you. In the case of most file-based sources, you can just use the SplFileObject class that comes with PHP.</p>

<p>Any arguments that were passed in the source: section of the YAML file will be available under $this->configuration. So if my YAML looks like this:</p>

<p><code>yaml
source:
  plugin: csv
  path: '/vagrant/import/ACS_13_1YR_B28002_with_ann.csv'
</code></p>

<p>My initializeIterator( ) method can look like this:</p>

<p>```php</p>

<p>public function initializeIterator() {
  // File handler using our custom header-rows-respecting extension of SPLFileObject.
  $file = new SplFileObject($this->configuration[&lsquo;path&rsquo;]);
  $file->setFlags(SplFileObject::READ_CSV);
  return $file;
}
```</p>

<p>Not too complicated, right? This method is called right at the beginning of the migration, the first time Migrate wants to get any information out of your source. The iterator will be stored in $this->iterator.</p>

<h2>getIds()</h2>

<p>This method should return an array of all the unique keys for your source. A unique key is some value that&rsquo;s unique for that row in the source material. Sometimes there&rsquo;s more than one, which is why this is an array. Each key field name is also an array, with a child &ldquo;type&rdquo; declaration. This is hard to explain in English, but easy to show in code:</p>

<p>```php
public function getIDs() {
  $ids = array();
  foreach ($this->configuration[&lsquo;keys&rsquo;] as $key) {</p>

<pre><code>$ids[$key]['type'] = 'string';
</code></pre>

<p>  }
  return $ids;
}
```</p>

<p>We rely on the YAML author to tell us the key fields in the CSV, and we just reformat them accordingly. Type can be &lsquo;string&rsquo;, &lsquo;float&rsquo;, &lsquo;integer&rsquo;, whatever makes sense.</p>

<h2>__toString()</h2>

<p>This method has to return a simple string explanation of the source query. In the case of a file-based source, it makes sense to print the path to the file, like this:</p>

<p><code>php
public function __toString() {
  return (string) $this-&gt;query;
}
</code></p>

<h2>fields()</h2>

<p>This method returns an array of available fields on the source. The keys should be the machine names, the values are descriptive, human-readable names. In the case of the CSV source, we look for headers at the top of the CSV file and build the array that way.</p>

<h2>__construct()</h2>

<p>The constructor method is called whenever a class is instantiated. You don&rsquo;t technically HAVE to have a constructor on your source class, but you&rsquo;ll find it helpful. For the CSV source, I used the constructor to make sure we have all the configuration that we need. Then I try and set sane values for fields, based on any header in the file.</p>

<p>```php
public function <strong>construct(array $configuration, $plugin_id, $plugin_definition, MigrationInterface $migration) {
  parent::</strong>construct($configuration, $plugin_id, $plugin_definition, $migration);</p>

<p>  // Path is required.
  if (empty($this->configuration[&lsquo;path&rsquo;])) {</p>

<pre><code>return new MigrateException('You must declare the "path" to the source CSV file in your source settings.');
</code></pre>

<p>  }</p>

<p>  // Key field(s) are required
  if (empty($this->configuration[&lsquo;keys&rsquo;])) {</p>

<pre><code>return new MigrateException('You must declare the "keys" the source CSV file in your source settings.');
</code></pre>

<p>  }</p>

<p>  // Set header rows from the migrate configuration.
  $this->headerRows = !empty($this->configuration[&lsquo;header_rows&rsquo;]) ? $this->configuration[&lsquo;header_rows&rsquo;] : 0;</p>

<p>  // Figure out what CSV columns we have.
  // One can either pass in an explicit list of column names to use, or if we have
  // a header row we can use the names from that
  if ($this->headerRows &amp;&amp; empty($this->configuration[&lsquo;csvColumns&rsquo;])) {</p>

<pre><code>$this-&gt;csvColumns = array();

// Skip all but the last header
for ($i = 0; $i &lt; $this-&gt;headerRows - 1; $i++) {
  $this-&gt;getNextLine();
}

$row = $this-&gt;getNextLine();
foreach ($row as $key =&gt; $header) {
  $header = trim($header);
  $this-&gt;getIterator()-&gt;csvColumns[] = array($header, $header);
}
</code></pre>

<p>  }
  elseif ($this->configuration[&lsquo;csvColumns&rsquo;]) {</p>

<pre><code>$this-&gt;getIterator()-&gt;csvColumns = $this-&gt;configuration['csvColumns'];
</code></pre>

<p>  }
}
```</p>

<h2>Profit!</h2>

<p>That&rsquo;s it! Four simple methods, and you have a new source type for Drupal 8 Migrate. Of course, you will probably find complications that require a bit more work. For CSV, supporting a header row turned out to be a real pain. Any time Migrate tried to &ldquo;rewind&rdquo; the source back to the first line, it would try and migrate the header row! I ended up extending SplFileObject just to handle this issue.</p>

<p>Here&rsquo;s the YAML file I used to test this, importing a list of states from some US Census data.</p>

<p>```yaml
id: states
label: States
migration_groups:
  &ndash; US Census</p>

<p>source:
  plugin: csv
  path: &lsquo;/vagrant/import/ACS_13_1YR_B28002_with_ann.csv&rsquo;
  header_rows: 2
  fields:</p>

<pre><code>- Id2
- Geography
</code></pre>

<p>  keys:</p>

<pre><code>- Id2
</code></pre>

<p>process:
  name: Geography
  vid:</p>

<pre><code>-
  plugin: default_value
  default_value: state
</code></pre>

<p>destination:
  plugin: entity:taxonomy_term
```</p>

<p>You can see my CSV source and Iterator in the <a href="https://www.drupal.org/node/2458003">issue queue for migrate_plus</a>. Good luck, and happy migrating!</p>

<h2>Thanks</h2>

<p>I learned a lot this week. Big thanks to the <a href="https://www.drupal.org/node/2127611">Migrate Documentation</a>, but especially to <a href="https://www.drupal.org/u/chx">chx</a>, <a href="https://www.drupal.org/u/mikeryan">mikeryan</a>, and the other good folks in #drupal-migrate who helped set me straight.</p>
]]></content>
  </entry>
  
</feed>
